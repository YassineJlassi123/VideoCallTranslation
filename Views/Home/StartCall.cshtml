@{
    ViewData["Title"] = "Video Call with Translation";
}

<h2 class="text-lg md:text-xl font-semibold text-center mb-4">Video Call with Translation</h2>

<div id="videoContainer" class="flex flex-col md:flex-row justify-center items-center mb-4">
    <video id="localVideo" autoplay muted class="w-full md:w-1/2 h-auto rounded-lg shadow-md"></video>
    <video id="remoteVideo" autoplay class="w-full md:w-1/2 h-auto rounded-lg shadow-md"></video>
</div>

<div id="translationContainer" class="max-w-lg mx-auto p-4 bg-white rounded-lg shadow-md">
    <div class="mb-4">
        <label for="sourceLang" class="block text-sm font-medium text-gray-700">Source Language:</label>
        <select id="sourceLang" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring focus:ring-primary">
            <option value="en-US">English</option>
            <option value="es-ES">Spanish</option>
            <option value="fr-FR">French</option>
            <option value="ar-SA">Arabic</option>
            <option value="ar-TN">Tunisian Arabic</option>
            <option value="ja-JP">Japanese</option>
            <option value="ko-KR">Korean</option>
            <option value="ru-RU">Russian</option>
        </select>
    </div>
    <div class="mb-4">
        <label for="targetLang" class="block text-sm font-medium text-gray-700">Target Language:</label>
        <select id="targetLang" class="mt-1 block w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring focus:ring-primary">
            <option value="es-ES">Spanish</option>
            <option value="en-US">English</option>
            <option value="fr-FR">French</option>
            <option value="ar-SA">Arabic</option>
            <option value="ar-TN">Tunisian Arabic</option>
            <option value="ja-JP">Japanese</option>
            <option value="ko-KR">Korean</option>
            <option value="ru-RU">Russian</option>
        </select>
    </div>
    <div id="controlsContainer" class="mt-4 hidden">
        <button id="endCallBtn" class="w-full bg-red-500 text-white p-2 rounded-md hover:bg-red-600 transition-colors">End Call</button>
    </div>
    <div id="recognitionStatus" class="text-sm text-gray-600 mt-2"></div>
    <div id="translatedText" class="text-gray-600 mt-4"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/8.0.0/signalr.min.js"></script>
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

<script>
    const roomId = '@ViewData["RoomId"]';
    let localStream, peerConnection, localRecognition, remoteRecognition;
    let remoteStream = new MediaStream();
    let isInitiator = false;

    const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/VideoCallHub")
        .build();

    async function startCall() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            document.getElementById('localVideo').srcObject = localStream;

            await connection.start();
            await connection.invoke("JoinRoom", roomId);

            setupPeerConnection();
            startSpeechRecognition('local');
        } catch (error) {
            console.error("Error starting call:", error);
            updateStatus("Error starting call. Please check your camera and microphone permissions.");
        }
    }

    function setupPeerConnection() {
        peerConnection = new RTCPeerConnection(configuration);

        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.ontrack = (event) => {
            event.streams[0].getTracks().forEach(track => {
                remoteStream.addTrack(track);
            });
            document.getElementById('remoteVideo').srcObject = remoteStream;
            startSpeechRecognition('remote');
        };

        peerConnection.onicecandidate = (event) => {
            if (event.candidate) {
                connection.invoke("SendIceCandidate", roomId, JSON.stringify(event.candidate));
            }
        };

        document.getElementById('controlsContainer').classList.remove('hidden');
    }

    function startSpeechRecognition(source) {
        const recognition = setupSpeechRecognition(source === 'local' ? 'sourceLang' : 'targetLang');
        if (!recognition) return;

        recognition.onresult = handleSpeechResult.bind(null, source);
        recognition.onend = () => {
            updateStatus(`${source === 'local' ? 'Local' : 'Remote'} recognition ended. Restarting...`);
            recognition.start();
        };
        recognition.onerror = (event) => {
            updateStatus(`${source === 'local' ? 'Local' : 'Remote'} recognition error: ${event.error}`);
            if (event.error === 'not-allowed') {
                updateStatus("Microphone access denied. Please check your browser settings.");
            } else {
                setTimeout(() => recognition.start(), 1000);
            }
        };

        try {
            recognition.start();
        } catch (error) {
            updateStatus(`Failed to start ${source} recognition: ${error.message}`);
        }

        if (source === 'local') {
            localRecognition = recognition;
        } else {
            remoteRecognition = recognition;
        }
    }

    function setupSpeechRecognition(langSelectId) {
        if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
            updateStatus("Speech recognition not supported in this browser.");
            return null;
        }

        const recognition = new (window.webkitSpeechRecognition || window.SpeechRecognition)();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = document.getElementById(langSelectId).value;

        return recognition;
    }

    async function handleSpeechResult(source, event) {
        let finalTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
                finalTranscript += event.results[i][0].transcript;
            }
        }

        if (finalTranscript) {
            const translation = await translateText(finalTranscript, source);
            displayTranslation(translation, source);

            if (source === 'local') {
                speakTranslation(translation);
                connection.invoke("SendTranslation", roomId, translation, document.getElementById('sourceLang').value, document.getElementById('targetLang').value);
            }
        }
    }

    async function translateText(text, source) {
        const sourceLang = document.getElementById(source === 'local' ? 'sourceLang' : 'targetLang').value;
        const targetLang = document.getElementById(source === 'local' ? 'targetLang' : 'sourceLang').value;

        try {
            const response = await fetch('/Home/Command', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ Text: text, SourceLang: sourceLang, TargetLang: targetLang }),
            });

            if (!response.ok) throw new Error("Network response was not ok");

            const data = await response.json();
            return data.translatedText;
        } catch (error) {
            console.error("Translation error:", error);
            return `Translation failed: ${error.message}`;
        }
    }

    function displayTranslation(translation, source) {
        const translationContainer = document.getElementById('translatedText');
        const sourceLabel = source === 'local' ? 'You' : 'Remote User';
        translationContainer.innerHTML += `<p><strong>${sourceLabel}:</strong> ${translation}</p>`;
    }

    function speakTranslation(translation) {
        const utterance = new SpeechSynthesisUtterance(translation);
        utterance.lang = document.getElementById('targetLang').value;
        speechSynthesis.speak(utterance);
    }

    function updateStatus(message) {
        document.getElementById('recognitionStatus').textContent = message;
    }

    connection.on("ReceiveOffer", async (offerString) => {
        const offer = JSON.parse(offerString);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        await connection.invoke("SendAnswer", roomId, JSON.stringify(answer));
    });

    connection.on("ReceiveAnswer", async (answerString) => {
        const answer = JSON.parse(answerString);
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
    });

    connection.on("ReceiveIceCandidate", async (candidateString) => {
        const candidate = JSON.parse(candidateString);
        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    });

    connection.on("UserJoined", async (userId) => {
        if (!isInitiator) {
            isInitiator = true;
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            await connection.invoke("SendOffer", roomId, JSON.stringify(offer));
        }
    });

    connection.on("ReceiveTranslation", (translation, sourceLang, targetLang) => {
        displayTranslation(translation, 'remote');
    });

    window.onload = startCall;

    document.getElementById('endCallBtn').onclick = async () => {
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }
        if (localRecognition) {
            localRecognition.stop();
        }
        if (remoteRecognition) {
            remoteRecognition.stop();
        }
        localStream.getTracks().forEach(track => track.stop());
        await connection.invoke("EndCall", roomId);
        window.location.href = '/'; // Redirect to home page or wherever appropriate
    };

    // Add event listeners for language selection changes
    document.getElementById('sourceLang').addEventListener('change', () => {
        if (localRecognition) {
            localRecognition.stop();
            startSpeechRecognition('local');
        }
    });

    document.getElementById('targetLang').addEventListener('change', () => {
        if (remoteRecognition) {
            remoteRecognition.stop();
            startSpeechRecognition('remote');
        }
    });
</script>




